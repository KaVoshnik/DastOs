# MyOS v0.7 - Полная документация операционной системы

## Содержание
1. [Обзор системы](#обзор-системы)
2. [Архитектура](#архитектура)
3. [Управление памятью](#управление-памятью)
4. [Планировщик задач](#планировщик-задач)
5. [Файловая система](#файловая-система)
6. [ELF загрузчик](#elf-загрузчик)
7. [Системные вызовы](#системные-вызовы)
8. [Обработка прерываний](#обработка-прерываний)
9. [Пользовательский интерфейс](#пользовательский-интерфейс)
10. [Разработчикам](#разработчикам)
11. [Тестирование](#тестирование)
12. [Известные ограничения](#известные-ограничения)

---

## Обзор системы

**MyOS v0.7** - это 32-битная операционная система, написанная на C и ассемблере для архитектуры x86. Система поддерживает многозадачность, виртуальную память, файловую систему, загрузку ELF-программ и полный набор системных вызовов.

### Ключевые особенности:
- **32-битная защищённая архитектура** с поддержкой Ring 0/3
- **Виртуальная память** с 4KB страницами и demand-paging
- **Многозадачность** с Round-Robin планировщиком
- **In-memory файловая система** с поддержкой директорий
- **ELF32 загрузчик** с поддержкой demand-paging
- **13 системных вызовов** с полной валидацией
- **Интерактивный шелл** с 20+ командами
- **Защита памяти** с guard-pages и user/kernel разделением

---

## Архитектура

### Загрузка системы
1. **GRUB** загружает ядро по Multiboot протоколу
2. **boot.asm** настраивает стек и передаёт управление в `kernel_main()`
3. **Инициализация подсистем** в строгом порядке:
   - GDT (Global Descriptor Table)
   - IDT (Interrupt Descriptor Table) 
   - PIC (Programmable Interrupt Controller)
   - Управление памятью
   - Файловая система
   - Планировщик задач
   - Процессы
   - Клавиатура и таймер

### Структура памяти
```
0x00000000 - 0x003FFFFF  (4MB)   - Ядро и код
0x00400000 - 0x004FFFFF  (1MB)   - Куча (heap)
0x00500000 - 0x005FFFFF  (1MB)   - Физические страницы
0x08000000 - 0x080FFFFF  (1MB)   - ELF загрузочная область
0x30000000 - 0x30000FFF  (4KB)   - Page Directory
0x30001000 - 0x30001FFF  (4KB)   - Page Tables
0xB8000000 - 0xB8000FFF  (4KB)   - VGA видеопамять
0xC0000000 - 0xFFFFFFFF  (1GB)   - Пользовательское пространство
```

---

## Управление памятью

### Виртуальная память
Система использует двухуровневую страничную адресацию:
- **Page Directory** (1024 записи по 4 байта)
- **Page Tables** (1024 записи по 4 байта каждая)
- **Размер страницы**: 4KB

### Физический аллокатор
```c
#define MAX_PHYS_PAGES (HEAP_SIZE / PAGE_SIZE)
static uint8_t phys_bitmap[MAX_PHYS_PAGES];
```
- **Bitmap-аллокатор** для управления физическими страницами
- **Счётчики**: выделенных и освобождённых страниц
- **Автоматическое освобождение** при завершении процессов

### Demand Paging
Система поддерживает подкачку страниц для ELF-программ:
- **Метаданные сегментов** сохраняются в `elf_loader_t`
- **Page fault handler** загружает страницы по требованию
- **Поддержка BSS** - нулевые страницы для неинициализированных данных

### Guard Pages
- **Автоматическое добавление** после выделенной памяти
- **Защита от переполнения** буфера
- **Page fault** при попытке доступа к guard-странице

### User/Kernel разделение
- **User space**: `0xC0000000 - 0xFFFFFFFF`
- **Kernel space**: `0x00000000 - 0xBFFFFFFF`
- **Валидация адресов** во всех системных вызовах
- **Безопасное копирование** через `copy_from_user/copy_to_user`

---

## Планировщик задач

### Структура задачи
```c
typedef struct task {
    uint32_t id;              // ID задачи
    char name[32];            // Имя задачи
    uint32_t state;           // Состояние (RUNNING/READY/BLOCKED/DEAD)
    uint32_t priority;        // Приоритет (0-255)
    registers_t regs;         // Сохранённые регистры
    uint32_t *stack;          // Стек задачи
    uint32_t stack_size;      // Размер стека
    uint32_t time_slice;      // Оставшееся время выполнения
    elf_loader_t *elf_loader; // ELF-загрузчик
    process_t process;        // Информация о процессе
    struct task *next;        // Следующая задача
} task_t;
```

### Round-Robin планировщик
- **Time slice**: 10 тиков таймера (100ms при 100Hz)
- **Приоритеты**: 256 уровней (0 = высший, 255 = низший)
- **Переключение контекста** с сохранением всех регистров
- **Поддержка yield** для добровольного переключения

### Управление процессами
- **Fork**: создание копии процесса
- **Exec**: замена образа процесса
- **Wait**: ожидание завершения дочернего процесса
- **Exit**: завершение процесса с очисткой ресурсов

---

## Файловая система

### In-Memory FS
Файловая система работает полностью в памяти:
- **Суперблок** с метаданными
- **Inode таблица** (64 записи)
- **Блоки данных** (256 блоков по 64 байта)
- **Битовые карты** для inodes и блоков

### Структуры данных
```c
typedef struct {
    uint8_t type;                   // Тип (файл/директория)
    char filename[32];              // Имя файла
    uint32_t size;                  // Размер в байтах
    uint32_t blocks[16];            // Прямые указатели на блоки
    uint32_t created_time;          // Время создания
    uint32_t modified_time;         // Время модификации
    uint32_t parent_inode;          // Родительская директория
} fs_inode_t;
```

### Поддерживаемые операции
- **Создание/удаление** файлов и директорий
- **Чтение/запись** файлов
- **Поиск** по имени
- **Список содержимого** директорий
- **Метаданные** (время создания/модификации)

---

## ELF загрузчик

### Поддержка ELF32
- **Валидация** магических чисел и заголовков
- **Парсинг** program headers
- **Загрузка** PT_LOAD сегментов
- **Настройка** пользовательского контекста

### Demand Paging
```c
typedef struct {
    uint32_t vaddr;           // Виртуальный адрес сегмента
    uint32_t offset;          // Смещение в файле
    uint32_t filesz;          // Размер в файле
    uint32_t memsz;           // Размер в памяти
    uint32_t flags;           // Флаги доступа
} segment_t;
```

### Процесс загрузки
1. **Валидация** ELF заголовка
2. **Сохранение** метаданных сегментов
3. **Отложенная загрузка** страниц по требованию
4. **Настройка** адресного пространства процесса

---

## Системные вызовы

### Таблица вызовов
| Номер | Имя | Описание | Аргументы |
|-------|-----|----------|-----------|
| 0 | exit | Завершение процесса | code |
| 1 | write | Запись в файл/консоль | fd, buf, count |
| 2 | read | Чтение из файла | fd, buf, count |
| 3 | open | Открытие файла | path, flags |
| 4 | close | Закрытие файла | fd |
| 5 | fork | Создание процесса | - |
| 6 | exec | Выполнение программы | path, argv |
| 7 | wait | Ожидание процесса | pid |
| 8 | getpid | Получение PID | - |
| 9 | yield | Добровольное переключение | - |
| 10 | sleep | Приостановка | seconds |
| 11 | getppid | PID родителя | - |
| 12 | getuid | User ID | - |
| 13 | getgid | Group ID | - |

### Валидация и безопасность
- **Проверка номеров** системных вызовов
- **Валидация адресов** пользовательских указателей
- **Безопасное копирование** данных между пространствами
- **Проверка прав доступа** к файлам

---

## Обработка прерываний

### IDT (Interrupt Descriptor Table)
- **256 записей** для всех векторов прерываний
- **Исключения 0-31** с обработчиками
- **IRQ 32-47** для аппаратных прерываний
- **INT 0x80** для системных вызовов

### Обработчики
- **Timer (IRQ0)**: планировщик задач, 100Hz
- **Keyboard (IRQ1)**: обработка клавиатуры
- **Page Fault (14)**: demand paging
- **System Call (128)**: диспетчер системных вызовов

### PIC настройка
- **IRQ0-7** → прерывания 32-39
- **IRQ8-15** → прерывания 40-47
- **EOI** отправляется после обработки
- **Маскирование** неиспользуемых прерываний

---

## Пользовательский интерфейс

### Интерактивный шелл
Система предоставляет полнофункциональный командный интерфейс:

#### Системные команды
- `help` - справка по командам
- `clear` - очистка экрана
- `about` - информация о системе
- `memory` - статистика памяти
- `reboot` - перезагрузка
- `poweroff` - выключение

#### Управление задачами
- `tasks` - список задач
- `ps` - список процессов
- `kill <pid>` - завершение процесса
- `fork` - тест fork
- `schedule` - принудительное переключение

#### Файловая система
- `ls` - список файлов
- `touch <file>` - создание файла
- `cat <file>` - просмотр файла
- `rm <file>` - удаление файла
- `echo <text> > <file>` - запись в файл
- `mkdir <dir>` - создание директории
- `rmdir <dir>` - удаление директории

#### ELF и тестирование
- `testelf` - тест встроенной ELF программы
- `run <file>` - запуск ELF файла
- `syscalls` - тест системных вызовов
- `memtest` - тест аллокатора памяти
- `keyboard` - статус клавиатуры

### VGA терминал
- **80x25 символов** с прокруткой
- **Курсор** с настраиваемой формой
- **Цвета** и форматирование
- **Backspace** и специальные символы

---

## Разработчикам

### Сборка системы

#### Требования
- **GCC** с поддержкой 32-битной архитектуры
- **NASM** ассемблер
- **Make** для автоматизации сборки
- **QEMU** для эмуляции

#### Процесс сборки
```bash
# Создание директории сборки
mkdir -p build

# Компиляция ассемблерных файлов
nasm -f elf32 src/boot/boot.asm -o build/boot.o
nasm -f elf32 src/kernel/interrupts.asm -o build/interrupts.o
nasm -f elf32 src/kernel/context.asm -o build/context.o
nasm -f elf32 src/kernel/usermode.asm -o build/usermode.o
nasm -f elf32 src/kernel/syscalls.asm -o build/syscalls.o

# Компиляция C файлов
gcc -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \
    -nostartfiles -nodefaultlibs -Wall -Wextra -Werror \
    -c -Isrc/include src/kernel/kernel.c -o build/kernel.o

gcc -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \
    -nostartfiles -nodefaultlibs -Wall -Wextra -Werror \
    -c -Isrc/include src/kernel/keyboard.c -o build/keyboard.o

# Линковка
ld -m elf_i386 -T src/linker.ld -o build/myos.bin \
    build/boot.o build/kernel.o build/keyboard.o \
    build/interrupts.o build/context.o build/usermode.o build/syscalls.o

# Создание ISO образа
mkdir -p isodir/boot/grub
cp build/myos.bin isodir/boot/
cp isodir/boot/grub/grub.cfg isodir/boot/grub/
grub-mkrescue -o myos.iso isodir
```

### Архитектура кода

#### Структура проекта
```
src/
├── boot/
│   └── boot.asm              # Multiboot загрузчик
├── kernel/
│   ├── kernel.c              # Основное ядро (3700+ строк)
│   ├── keyboard.c            # Модуль клавиатуры
│   ├── interrupts.asm        # Обработчики прерываний
│   ├── context.asm           # Переключение контекста
│   ├── usermode.asm          # Пользовательский режим
│   └── syscalls.asm          # Системные вызовы
├── include/
│   ├── types.h               # Базовые типы
│   ├── elf.h                 # ELF структуры
│   └── keyboard.h            # Клавиатурные константы
└── linker.ld                 # Скрипт линковки
```

#### Ключевые модули

**kernel.c** - центральный модуль системы:
- Управление памятью (heap, paging, demand-paging)
- Планировщик задач и процессы
- Файловая система
- ELF загрузчик
- Системные вызовы
- Командный интерфейс

**keyboard.c** - обработка клавиатуры:
- Сканкод таблица (256 клавиш)
- Модификаторы (Shift, Ctrl, Alt, Caps Lock)
- Расширенные клавиши (F1-F12, стрелки)
- Event-driven архитектура

**interrupts.asm** - низкоуровневые обработчики:
- IRQ обработчики с EOI
- Exception handlers
- Page fault handler
- System call dispatcher

### Добавление новых функций

#### Новый системный вызов
1. Добавить номер в `#define SYS_NEWCALL 21`
2. Реализовать функцию `sys_newcall_impl()`
3. Добавить в таблицу `syscall_table[]`
4. Обновить документацию

#### Новый обработчик прерываний
1. Добавить обработчик в `interrupts.asm`
2. Установить в IDT в `kernel_main()`
3. Настроить PIC маски
4. Реализовать C-обработчик

#### Новая команда шелла
1. Добавить функцию `command_newcmd()`
2. Добавить в `execute_command()`
3. Обновить `command_help()`
4. Добавить в документацию

### Отладка

#### QEMU с GDB
```bash
# Запуск с GDB сервером
qemu-system-i386 -cdrom myos.iso -s -S

# Подключение GDB
gdb build/myos.bin
(gdb) target remote :1234
(gdb) break kernel_main
(gdb) continue
```

#### Логирование
- Используйте `terminal_writestring()` для отладки
- `print_hex()` для вывода адресов
- `dump_registers()` в критических местах

---

## Тестирование

### Автоматические тесты

#### Тест системных вызовов
```bash
# В шелле выполните:
myos> syscalls
```
**Ожидаемый результат:**
- `getpid() = <число>`
- `write(1, "Hello from syscall!", 20) = 20`
- `getppid() = <число>`
- `getuid() = 0, getgid() = 0`

#### Тест ELF загрузчика
```bash
# Тест встроенной программы
myos> testelf

# Тест файла из ФС
myos> echo "test data" > test.txt
myos> run test.txt
```
**Ожидаемый результат:**
- Успешная загрузка ELF
- Создание задачи
- Корректное завершение

#### Тест памяти
```bash
# Статистика памяти
myos> memory

# Тест аллокатора
myos> memtest
```
**Ожидаемый результат:**
- Корректные счётчики памяти
- Успешное выделение/освобождение
- Статистика физических страниц

### Ручное тестирование

#### Тест многозадачности
1. Запустите `tasks` - должны быть демо-задачи
2. Выполните `schedule` - должно произойти переключение
3. Создайте новую задачу через `fork`

#### Тест файловой системы
1. Создайте файл: `echo "Hello World" > hello.txt`
2. Прочитайте файл: `cat hello.txt`
3. Создайте директорию: `mkdir testdir`
4. Удалите файл: `rm hello.txt`

#### Тест demand-paging
1. Загрузите ELF программу
2. Обратитесь к неотображённой странице
3. Система должна подкачать страницу без падения

#### Тест защиты памяти
1. Попробуйте передать kernel-адрес в syscall
2. Должно вернуться -1 (отклонение)
3. Попробуйте обратиться к guard-странице
4. Должен произойти page fault

### Стресс-тестирование

#### Тест стабильности
```bash
# Многократное выполнение команд
for i in {1..100}; do
    myos> memory
    myos> tasks
    myos> syscalls
done
```

#### Тест памяти
```bash
# Создание множества файлов
for i in {1..50}; do
    myos> echo "File $i" > file$i.txt
done

# Проверка статистики
myos> memory
myos> ls
```

### Известные проблемы

1. **Клавиатура**: некоторые комбинации клавиш могут не обрабатываться
2. **ELF**: ограниченная поддержка сложных программ
3. **Память**: нет дефрагментации heap
4. **ФС**: нет поддержки вложенных директорий

### Отчёт об ошибках

При обнаружении проблем укажите:
1. **Команду** или действие, вызвавшее ошибку
2. **Ожидаемое поведение**
3. **Фактическое поведение**
4. **Вывод команды `memory`**
5. **Скриншот** если возможно

---

## Известные ограничения

### Архитектурные ограничения
- **Только x86 32-bit** архитектура
- **Максимум 8 задач** одновременно
- **1MB лимит** памяти на процесс
- **64 файла** в файловой системе

### Функциональные ограничения
- **Нет сетевого стека**
- **Нет драйверов** для жёстких дисков
- **Ограниченная поддержка** ELF (только статические)
- **Нет поддержки** многопоточности

### Производительность
- **Простой планировщик** без приоритетов
- **Линейный поиск** в файловой системе
- **Нет кэширования** страниц
- **Синхронный I/O** только

---

## Заключение

MyOS v0.7 представляет собой полнофункциональную операционную систему с современными возможностями управления памятью, многозадачности и файловой системы. Система демонстрирует все основные концепции ОС и может служить основой для дальнейшего развития.

**Основные достижения:**
- Стабильная работа всех подсистем
- Полная поддержка пользовательского режима
- Эффективное управление памятью
- Современный интерфейс разработчика

**Направления развития:**
- Поддержка сетевых протоколов
- Расширенная файловая система
- Драйверы устройств
- Многопоточность
- 64-битная архитектура